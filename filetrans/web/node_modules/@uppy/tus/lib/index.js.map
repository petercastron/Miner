{"version":3,"sources":["index.js"],"names":["BasePlugin","emitSocketProgress","getSocketHost","settle","EventTracker","NetworkError","isNetworkError","hasProperty","getFingerprint","packageJson","tusDefaultOptions","endpoint","uploadUrl","metadata","uploadSize","onProgress","onChunkComplete","onSuccess","onError","overridePatchMethod","headers","addRequestId","chunkSize","Infinity","retryDelays","parallelUploads","removeFingerprintOnSuccess","uploadLengthDeferred","uploadDataDuringCreation","Tus","constructor","uppy","opts","file","Client","remote","providerOptions","provider","Provider","RequestClient","client","tus","Object","assign","res","post","url","body","protocol","size","data","meta","token","type","id","title","defaultOptions","useFastRemoteRetry","limit","withCredentials","Error","requests","rateLimitedQueue","RateLimitedQueue","values","uploaders","create","uploaderEvents","uploaderSockets","handleResetProgress","bind","handleUpload","wrapPromiseFunction","files","getState","keys","forEach","fileID","tusState","setState","resetUploaderReferences","uploader","abort","remove","close","upload","Promise","resolve","reject","queuedRequest","qRequest","emit","uploadOptions","fingerprint","onBeforeRequest","req","xhr","getUnderlyingObject","userProvidedPromise","shouldBeRequeued","done","p","run","isPaused","all","err","log","originalRequest","bytesUploaded","bytesTotal","onReceiveUploadUrl","uploadResp","uploadURL","name","defaultOnShouldRetry","status","originalResponse","getStatus","next","rateLimit","value","navigator","onLine","pause","window","addEventListener","resume","once","fn","onShouldRetry","args","copyProp","obj","srcProp","destProp","metaFields","Array","isArray","item","Upload","start","findPreviousUploads","then","previousUploads","previousUpload","creationTime","resumeFromPreviousUpload","onFileRemove","targetFileID","onPause","onPauseAll","onCancelAll","reason","onResumeAll","error","catch","uploadRemote","progress","uploadStarted","isRestored","serverToken","connectToServerSocket","undefined","setFileState","getFile","host","companionUrl","socket","Socket","target","send","onRetry","isOpen","onRetryAll","on","progressData","errData","message","cause","currentFile","cb","eventHandler","uploadFiles","promises","map","i","current","total","length","isRemote","fileIDs","filesToUpload","install","capabilities","resumableUploads","addUploader","uninstall","removeUploader","VERSION","version"],"mappings":"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","sourcesContent":["import BasePlugin from '@uppy/core/lib/BasePlugin'\nimport * as tus from 'tus-js-client'\nimport { Provider, RequestClient, Socket } from '@uppy/companion-client'\nimport emitSocketProgress from '@uppy/utils/lib/emitSocketProgress'\nimport getSocketHost from '@uppy/utils/lib/getSocketHost'\nimport settle from '@uppy/utils/lib/settle'\nimport EventTracker from '@uppy/utils/lib/EventTracker'\nimport NetworkError from '@uppy/utils/lib/NetworkError'\nimport isNetworkError from '@uppy/utils/lib/isNetworkError'\nimport { RateLimitedQueue } from '@uppy/utils/lib/RateLimitedQueue'\nimport hasProperty from '@uppy/utils/lib/hasProperty'\nimport getFingerprint from './getFingerprint.js'\n\nimport packageJson from '../package.json'\n\n/** @typedef {import('..').TusOptions} TusOptions */\n/** @typedef {import('tus-js-client').UploadOptions} RawTusOptions */\n/** @typedef {import('@uppy/core').Uppy} Uppy */\n/** @typedef {import('@uppy/core').UppyFile} UppyFile */\n/** @typedef {import('@uppy/core').FailedUppyFile<{}>} FailedUppyFile */\n\n/**\n * Extracted from https://github.com/tus/tus-js-client/blob/master/lib/upload.js#L13\n * excepted we removed 'fingerprint' key to avoid adding more dependencies\n *\n * @type {RawTusOptions}\n */\nconst tusDefaultOptions = {\n  endpoint: '',\n\n  uploadUrl: null,\n  metadata: {},\n  uploadSize: null,\n\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n\n  overridePatchMethod: false,\n  headers: {},\n  addRequestId: false,\n\n  chunkSize: Infinity,\n  retryDelays: [100, 1000, 3000, 5000],\n  parallelUploads: 1,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  uploadDataDuringCreation: false,\n}\n\n/**\n * Tus resumable file uploader\n */\nexport default class Tus extends BasePlugin {\n  static VERSION = packageJson.version\n\n  #retryDelayIterator\n\n  #queueRequestSocketToken\n\n  /**\n   * @param {Uppy} uppy\n   * @param {TusOptions} opts\n   */\n  constructor (uppy, opts) {\n    super(uppy, opts)\n    this.type = 'uploader'\n    this.id = this.opts.id || 'Tus'\n    this.title = 'Tus'\n\n    // set default options\n    const defaultOptions = {\n      useFastRemoteRetry: true,\n      limit: 20,\n      retryDelays: tusDefaultOptions.retryDelays,\n      withCredentials: false,\n    }\n\n    // merge default options with the ones set by user\n    /** @type {import(\"..\").TusOptions} */\n    this.opts = { ...defaultOptions, ...opts }\n\n    if ('autoRetry' in opts) {\n      throw new Error('The `autoRetry` option was deprecated and has been removed.')\n    }\n\n    /**\n     * Simultaneous upload limiting is shared across all uploads with this plugin.\n     *\n     * @type {RateLimitedQueue}\n     */\n    this.requests = this.opts.rateLimitedQueue ?? new RateLimitedQueue(this.opts.limit)\n    this.#retryDelayIterator = this.opts.retryDelays?.values()\n\n    this.uploaders = Object.create(null)\n    this.uploaderEvents = Object.create(null)\n    this.uploaderSockets = Object.create(null)\n\n    this.handleResetProgress = this.handleResetProgress.bind(this)\n    this.handleUpload = this.handleUpload.bind(this)\n    this.#queueRequestSocketToken = this.requests.wrapPromiseFunction(this.#requestSocketToken)\n  }\n\n  handleResetProgress () {\n    const files = { ...this.uppy.getState().files }\n    Object.keys(files).forEach((fileID) => {\n      // Only clone the file object if it has a Tus `uploadUrl` attached.\n      if (files[fileID].tus && files[fileID].tus.uploadUrl) {\n        const tusState = { ...files[fileID].tus }\n        delete tusState.uploadUrl\n        files[fileID] = { ...files[fileID], tus: tusState }\n      }\n    })\n\n    this.uppy.setState({ files })\n  }\n\n  /**\n   * Clean up all references for a file's upload: the tus.Upload instance,\n   * any events related to the file, and the Companion WebSocket connection.\n   *\n   * @param {string} fileID\n   */\n  resetUploaderReferences (fileID, opts = {}) {\n    if (this.uploaders[fileID]) {\n      const uploader = this.uploaders[fileID]\n\n      uploader.abort()\n\n      if (opts.abort) {\n        uploader.abort(true)\n      }\n\n      this.uploaders[fileID] = null\n    }\n    if (this.uploaderEvents[fileID]) {\n      this.uploaderEvents[fileID].remove()\n      this.uploaderEvents[fileID] = null\n    }\n    if (this.uploaderSockets[fileID]) {\n      this.uploaderSockets[fileID].close()\n      this.uploaderSockets[fileID] = null\n    }\n  }\n\n  /**\n   * Create a new Tus upload.\n   *\n   * A lot can happen during an upload, so this is quite hard to follow!\n   * - First, the upload is started. If the file was already paused by the time the upload starts, nothing should happen.\n   *   If the `limit` option is used, the upload must be queued onto the `this.requests` queue.\n   *   When an upload starts, we store the tus.Upload instance, and an EventTracker instance that manages the event listeners\n   *   for pausing, cancellation, removal, etc.\n   * - While the upload is in progress, it may be paused or cancelled.\n   *   Pausing aborts the underlying tus.Upload, and removes the upload from the `this.requests` queue. All other state is\n   *   maintained.\n   *   Cancelling removes the upload from the `this.requests` queue, and completely aborts the upload-- the `tus.Upload`\n   *   instance is aborted and discarded, the EventTracker instance is destroyed (removing all listeners).\n   *   Resuming the upload uses the `this.requests` queue as well, to prevent selectively pausing and resuming uploads from\n   *   bypassing the limit.\n   * - After completing an upload, the tus.Upload and EventTracker instances are cleaned up, and the upload is marked as done\n   *   in the `this.requests` queue.\n   * - When an upload completed with an error, the same happens as on successful completion, but the `upload()` promise is\n   *   rejected.\n   *\n   * When working on this function, keep in mind:\n   *  - When an upload is completed or cancelled for any reason, the tus.Upload and EventTracker instances need to be cleaned\n   *    up using this.resetUploaderReferences().\n   *  - When an upload is cancelled or paused, for any reason, it needs to be removed from the `this.requests` queue using\n   *    `queuedRequest.abort()`.\n   *  - When an upload is completed for any reason, including errors, it needs to be marked as such using\n   *    `queuedRequest.done()`.\n   *  - When an upload is started or resumed, it needs to go through the `this.requests` queue. The `queuedRequest` variable\n   *    must be updated so the other uses of it are valid.\n   *  - Before replacing the `queuedRequest` variable, the previous `queuedRequest` must be aborted, else it will keep taking\n   *    up a spot in the queue.\n   *\n   * @param {UppyFile} file for use with upload\n   * @returns {Promise<void>}\n   */\n  upload (file) {\n    this.resetUploaderReferences(file.id)\n\n    // Create a new tus upload\n    return new Promise((resolve, reject) => {\n      let queuedRequest\n      let qRequest\n      let upload\n\n      this.uppy.emit('upload-started', file)\n\n      const opts = {\n        ...this.opts,\n        ...(file.tus || {}),\n      }\n\n      if (typeof opts.headers === 'function') {\n        opts.headers = opts.headers(file)\n      }\n\n      /** @type {RawTusOptions} */\n      const uploadOptions = {\n        ...tusDefaultOptions,\n        ...opts,\n      }\n\n      // We override tus fingerprint to uppy’s `file.id`, since the `file.id`\n      // now also includes `relativePath` for files added from folders.\n      // This means you can add 2 identical files, if one is in folder a,\n      // the other in folder b.\n      uploadOptions.fingerprint = getFingerprint(file)\n\n      uploadOptions.onBeforeRequest = (req) => {\n        const xhr = req.getUnderlyingObject()\n        xhr.withCredentials = !!opts.withCredentials\n\n        let userProvidedPromise\n        if (typeof opts.onBeforeRequest === 'function') {\n          userProvidedPromise = opts.onBeforeRequest(req, file)\n        }\n\n        if (hasProperty(queuedRequest, 'shouldBeRequeued')) {\n          if (!queuedRequest.shouldBeRequeued) return Promise.reject()\n          let done\n          const p = new Promise((res) => { // eslint-disable-line promise/param-names\n            done = res\n          })\n          queuedRequest = this.requests.run(() => {\n            if (file.isPaused) {\n              queuedRequest.abort()\n            }\n            done()\n            return () => {}\n          })\n          // If the request has been requeued because it was rate limited by the\n          // remote server, we want to wait for `RateLimitedQueue` to dispatch\n          // the re-try request.\n          // Therefore we create a promise that the queue will resolve when\n          // enough time has elapsed to expect not to be rate-limited again.\n          // This means we can hold the Tus retry here with a `Promise.all`,\n          // together with the returned value of the user provided\n          // `onBeforeRequest` option callback (in case it returns a promise).\n          return Promise.all([p, userProvidedPromise])\n        }\n        return userProvidedPromise\n      }\n\n      uploadOptions.onError = (err) => {\n        this.uppy.log(err)\n\n        const xhr = err.originalRequest ? err.originalRequest.getUnderlyingObject() : null\n        if (isNetworkError(xhr)) {\n          // eslint-disable-next-line no-param-reassign\n          err = new NetworkError(err, xhr)\n        }\n\n        this.resetUploaderReferences(file.id)\n        queuedRequest?.abort()\n\n        this.uppy.emit('upload-error', file, err)\n\n        reject(err)\n      }\n\n      uploadOptions.onProgress = (bytesUploaded, bytesTotal) => {\n        this.onReceiveUploadUrl(file, upload.url)\n        this.uppy.emit('upload-progress', file, {\n          uploader: this,\n          bytesUploaded,\n          bytesTotal,\n        })\n      }\n\n      uploadOptions.onSuccess = () => {\n        const uploadResp = {\n          uploadURL: upload.url,\n        }\n\n        this.resetUploaderReferences(file.id)\n        queuedRequest.done()\n\n        this.uppy.emit('upload-success', file, uploadResp)\n\n        if (upload.url) {\n          this.uppy.log(`Download ${upload.file.name} from ${upload.url}`)\n        }\n\n        resolve(upload)\n      }\n\n      const defaultOnShouldRetry = (err) => {\n        const status = err?.originalResponse?.getStatus()\n\n        if (status === 429) {\n          // HTTP 429 Too Many Requests => to avoid the whole download to fail, pause all requests.\n          if (!this.requests.isPaused) {\n            const next = this.#retryDelayIterator?.next()\n            if (next == null || next.done) {\n              return false\n            }\n            this.requests.rateLimit(next.value)\n          }\n        } else if (status > 400 && status < 500 && status !== 409) {\n          // HTTP 4xx, the server won't send anything, it's doesn't make sense to retry\n          return false\n        } else if (typeof navigator !== 'undefined' && navigator.onLine === false) {\n          // The navigator is offline, let's wait for it to come back online.\n          if (!this.requests.isPaused) {\n            this.requests.pause()\n            window.addEventListener('online', () => {\n              this.requests.resume()\n            }, { once: true })\n          }\n        }\n        queuedRequest.abort()\n        queuedRequest = {\n          shouldBeRequeued: true,\n          abort () {\n            this.shouldBeRequeued = false\n          },\n          done () {\n            throw new Error('Cannot mark a queued request as done: this indicates a bug')\n          },\n          fn () {\n            throw new Error('Cannot run a queued request: this indicates a bug')\n          },\n        }\n        return true\n      }\n\n      if (opts.onShouldRetry != null) {\n        uploadOptions.onShouldRetry = (...args) => opts.onShouldRetry(...args, defaultOnShouldRetry)\n      } else {\n        uploadOptions.onShouldRetry = defaultOnShouldRetry\n      }\n\n      const copyProp = (obj, srcProp, destProp) => {\n        if (hasProperty(obj, srcProp) && !hasProperty(obj, destProp)) {\n          // eslint-disable-next-line no-param-reassign\n          obj[destProp] = obj[srcProp]\n        }\n      }\n\n      /** @type {Record<string, string>} */\n      const meta = {}\n      const metaFields = Array.isArray(opts.metaFields)\n        ? opts.metaFields\n        // Send along all fields by default.\n        : Object.keys(file.meta)\n      metaFields.forEach((item) => {\n        meta[item] = file.meta[item]\n      })\n\n      // tusd uses metadata fields 'filetype' and 'filename'\n      copyProp(meta, 'type', 'filetype')\n      copyProp(meta, 'name', 'filename')\n\n      uploadOptions.metadata = meta\n\n      upload = new tus.Upload(file.data, uploadOptions)\n      this.uploaders[file.id] = upload\n      this.uploaderEvents[file.id] = new EventTracker(this.uppy)\n\n      // eslint-disable-next-line prefer-const\n      qRequest = () => {\n        if (!file.isPaused) {\n          upload.start()\n        }\n        // Don't do anything here, the caller will take care of cancelling the upload itself\n        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be\n        // called when this request is still in the queue, and has not been started yet, too. At\n        // that point this cancellation function is not going to be called.\n        // Also, we need to remove the request from the queue _without_ destroying everything\n        // related to this upload to handle pauses.\n        return () => {}\n      }\n\n      upload.findPreviousUploads().then((previousUploads) => {\n        const previousUpload = previousUploads[0]\n        if (previousUpload) {\n          this.uppy.log(`[Tus] Resuming upload of ${file.id} started at ${previousUpload.creationTime}`)\n          upload.resumeFromPreviousUpload(previousUpload)\n        }\n      })\n\n      queuedRequest = this.requests.run(qRequest)\n\n      this.onFileRemove(file.id, (targetFileID) => {\n        queuedRequest.abort()\n        this.resetUploaderReferences(file.id, { abort: !!upload.url })\n        resolve(`upload ${targetFileID} was removed`)\n      })\n\n      this.onPause(file.id, (isPaused) => {\n        queuedRequest.abort()\n        if (isPaused) {\n          // Remove this file from the queue so another file can start in its place.\n          upload.abort()\n        } else {\n          // Resuming an upload should be queued, else you could pause and then\n          // resume a queued upload to make it skip the queue.\n          queuedRequest = this.requests.run(qRequest)\n        }\n      })\n\n      this.onPauseAll(file.id, () => {\n        queuedRequest.abort()\n        upload.abort()\n      })\n\n      this.onCancelAll(file.id, ({ reason } = {}) => {\n        if (reason === 'user') {\n          queuedRequest.abort()\n          this.resetUploaderReferences(file.id, { abort: !!upload.url })\n        }\n        resolve(`upload ${file.id} was canceled`)\n      })\n\n      this.onResumeAll(file.id, () => {\n        queuedRequest.abort()\n        if (file.error) {\n          upload.abort()\n        }\n        queuedRequest = this.requests.run(qRequest)\n      })\n    }).catch((err) => {\n      this.uppy.emit('upload-error', file, err)\n      throw err\n    })\n  }\n\n  #requestSocketToken = async (file) => {\n    const Client = file.remote.providerOptions.provider ? Provider : RequestClient\n    const client = new Client(this.uppy, file.remote.providerOptions)\n    const opts = { ...this.opts }\n\n    if (file.tus) {\n      // Install file-specific upload overrides.\n      Object.assign(opts, file.tus)\n    }\n\n    const res = await client.post(file.remote.url, {\n      ...file.remote.body,\n      endpoint: opts.endpoint,\n      uploadUrl: opts.uploadUrl,\n      protocol: 'tus',\n      size: file.data.size,\n      headers: opts.headers,\n      metadata: file.meta,\n    })\n    return res.token\n  }\n\n  /**\n   * @param {UppyFile} file for use with upload\n   * @returns {Promise<void>}\n   */\n  async uploadRemote (file) {\n    this.resetUploaderReferences(file.id)\n\n    // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n    if (!file.progress.uploadStarted || !file.isRestored) {\n      this.uppy.emit('upload-started', file)\n    }\n\n    try {\n      if (file.serverToken) {\n        return this.connectToServerSocket(file)\n      }\n      const serverToken = await this.#queueRequestSocketToken(file)\n\n      if (!this.uppy.getState().files[file.id]) return undefined\n\n      this.uppy.setFileState(file.id, { serverToken })\n      return this.connectToServerSocket(this.uppy.getFile(file.id))\n    } catch (err) {\n      this.uppy.emit('upload-error', file, err)\n      throw err\n    }\n  }\n\n  /**\n   * See the comment on the upload() method.\n   *\n   * Additionally, when an upload is removed, completed, or cancelled, we need to close the WebSocket connection. This is\n   * handled by the resetUploaderReferences() function, so the same guidelines apply as in upload().\n   *\n   * @param {UppyFile} file\n   */\n  connectToServerSocket (file) {\n    return new Promise((resolve, reject) => {\n      const token = file.serverToken\n      const host = getSocketHost(file.remote.companionUrl)\n      const socket = new Socket({ target: `${host}/api/${token}` })\n      this.uploaderSockets[file.id] = socket\n      this.uploaderEvents[file.id] = new EventTracker(this.uppy)\n\n      let queuedRequest\n\n      this.onFileRemove(file.id, () => {\n        queuedRequest.abort()\n        socket.send('cancel', {})\n        this.resetUploaderReferences(file.id)\n        resolve(`upload ${file.id} was removed`)\n      })\n\n      this.onPause(file.id, (isPaused) => {\n        if (isPaused) {\n          // Remove this file from the queue so another file can start in its place.\n          queuedRequest.abort()\n          socket.send('pause', {})\n        } else {\n          // Resuming an upload should be queued, else you could pause and then\n          // resume a queued upload to make it skip the queue.\n          queuedRequest.abort()\n          queuedRequest = this.requests.run(() => {\n            socket.send('resume', {})\n            return () => {}\n          })\n        }\n      })\n\n      this.onPauseAll(file.id, () => {\n        queuedRequest.abort()\n        socket.send('pause', {})\n      })\n\n      this.onCancelAll(file.id, ({ reason } = {}) => {\n        if (reason === 'user') {\n          queuedRequest.abort()\n          socket.send('cancel', {})\n          this.resetUploaderReferences(file.id)\n        }\n        resolve(`upload ${file.id} was canceled`)\n      })\n\n      this.onResumeAll(file.id, () => {\n        queuedRequest.abort()\n        if (file.error) {\n          socket.send('pause', {})\n        }\n        queuedRequest = this.requests.run(() => {\n          socket.send('resume', {})\n          return () => {}\n        })\n      })\n\n      this.onRetry(file.id, () => {\n        // Only do the retry if the upload is actually in progress;\n        // else we could try to send these messages when the upload is still queued.\n        // We may need a better check for this since the socket may also be closed\n        // for other reasons, like network failures.\n        if (socket.isOpen) {\n          socket.send('pause', {})\n          socket.send('resume', {})\n        }\n      })\n\n      this.onRetryAll(file.id, () => {\n        // See the comment in the onRetry() call\n        if (socket.isOpen) {\n          socket.send('pause', {})\n          socket.send('resume', {})\n        }\n      })\n\n      socket.on('progress', (progressData) => emitSocketProgress(this, progressData, file))\n\n      socket.on('error', (errData) => {\n        const { message } = errData.error\n        const error = Object.assign(new Error(message), { cause: errData.error })\n\n        // If the remote retry optimisation should not be used,\n        // close the socket—this will tell companion to clear state and delete the file.\n        if (!this.opts.useFastRemoteRetry) {\n          this.resetUploaderReferences(file.id)\n          // Remove the serverToken so that a new one will be created for the retry.\n          this.uppy.setFileState(file.id, {\n            serverToken: null,\n          })\n        } else {\n          socket.close()\n        }\n\n        this.uppy.emit('upload-error', file, error)\n        queuedRequest.done()\n        reject(error)\n      })\n\n      socket.on('success', (data) => {\n        const uploadResp = {\n          uploadURL: data.url,\n        }\n\n        this.uppy.emit('upload-success', file, uploadResp)\n        this.resetUploaderReferences(file.id)\n        queuedRequest.done()\n\n        resolve()\n      })\n\n      queuedRequest = this.requests.run(() => {\n        if (file.isPaused) {\n          socket.send('pause', {})\n        }\n\n        // Don't do anything here, the caller will take care of cancelling the upload itself\n        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be\n        // called when this request is still in the queue, and has not been started yet, too. At\n        // that point this cancellation function is not going to be called.\n        // Also, we need to remove the request from the queue _without_ destroying everything\n        // related to this upload to handle pauses.\n        return () => {}\n      })\n    })\n  }\n\n  /**\n   * Store the uploadUrl on the file options, so that when Golden Retriever\n   * restores state, we will continue uploading to the correct URL.\n   *\n   * @param {UppyFile} file\n   * @param {string} uploadURL\n   */\n  onReceiveUploadUrl (file, uploadURL) {\n    const currentFile = this.uppy.getFile(file.id)\n    if (!currentFile) return\n    // Only do the update if we didn't have an upload URL yet.\n    if (!currentFile.tus || currentFile.tus.uploadUrl !== uploadURL) {\n      this.uppy.log('[Tus] Storing upload url')\n      this.uppy.setFileState(currentFile.id, {\n        tus: { ...currentFile.tus, uploadUrl: uploadURL },\n      })\n    }\n  }\n\n  /**\n   * @param {string} fileID\n   * @param {function(string): void} cb\n   */\n  onFileRemove (fileID, cb) {\n    this.uploaderEvents[fileID].on('file-removed', (file) => {\n      if (fileID === file.id) cb(file.id)\n    })\n  }\n\n  /**\n   * @param {string} fileID\n   * @param {function(boolean): void} cb\n   */\n  onPause (fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-pause', (targetFileID, isPaused) => {\n      if (fileID === targetFileID) {\n        // const isPaused = this.uppy.pauseResume(fileID)\n        cb(isPaused)\n      }\n    })\n  }\n\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  onRetry (fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-retry', (targetFileID) => {\n      if (fileID === targetFileID) {\n        cb()\n      }\n    })\n  }\n\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  onRetryAll (fileID, cb) {\n    this.uploaderEvents[fileID].on('retry-all', () => {\n      if (!this.uppy.getFile(fileID)) return\n      cb()\n    })\n  }\n\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  onPauseAll (fileID, cb) {\n    this.uploaderEvents[fileID].on('pause-all', () => {\n      if (!this.uppy.getFile(fileID)) return\n      cb()\n    })\n  }\n\n  /**\n   * @param {string} fileID\n   * @param {function(): void} eventHandler\n   */\n  onCancelAll (fileID, eventHandler) {\n    this.uploaderEvents[fileID].on('cancel-all', (...args) => {\n      if (!this.uppy.getFile(fileID)) return\n      eventHandler(...args)\n    })\n  }\n\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  onResumeAll (fileID, cb) {\n    this.uploaderEvents[fileID].on('resume-all', () => {\n      if (!this.uppy.getFile(fileID)) return\n      cb()\n    })\n  }\n\n  /**\n   * @param {(UppyFile | FailedUppyFile)[]} files\n   */\n  uploadFiles (files) {\n    const promises = files.map((file, i) => {\n      const current = i + 1\n      const total = files.length\n\n      if ('error' in file && file.error) {\n        return Promise.reject(new Error(file.error))\n      } if (file.isRemote) {\n        // We emit upload-started here, so that it's also emitted for files\n        // that have to wait due to the `limit` option.\n        // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n        if (!file.progress.uploadStarted || !file.isRestored) {\n          this.uppy.emit('upload-started', file)\n        }\n        return this.uploadRemote(file, current, total)\n      }\n      // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n      if (!file.progress.uploadStarted || !file.isRestored) {\n        this.uppy.emit('upload-started', file)\n      }\n      return this.upload(file, current, total)\n    })\n\n    return settle(promises)\n  }\n\n  /**\n   * @param {string[]} fileIDs\n   */\n  handleUpload (fileIDs) {\n    if (fileIDs.length === 0) {\n      this.uppy.log('[Tus] No files to upload')\n      return Promise.resolve()\n    }\n\n    if (this.opts.limit === 0) {\n      this.uppy.log(\n        '[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0',\n        'warning',\n      )\n    }\n\n    this.uppy.log('[Tus] Uploading...')\n    const filesToUpload = fileIDs.map((fileID) => this.uppy.getFile(fileID))\n\n    return this.uploadFiles(filesToUpload)\n      .then(() => null)\n  }\n\n  install () {\n    this.uppy.setState({\n      capabilities: { ...this.uppy.getState().capabilities, resumableUploads: true },\n    })\n    this.uppy.addUploader(this.handleUpload)\n\n    this.uppy.on('reset-progress', this.handleResetProgress)\n  }\n\n  uninstall () {\n    this.uppy.setState({\n      capabilities: { ...this.uppy.getState().capabilities, resumableUploads: false },\n    })\n    this.uppy.removeUploader(this.handleUpload)\n  }\n}\n"]}